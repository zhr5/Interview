# 常见线上问题清单



| CPU                                                  |      |      |
| ---------------------------------------------------- | ---- | ---- |
| GC问题 -youngGC 过频繁  youngGC 耗时过长 频繁 fullGC |      |      |
| 磁盘                                                 |      |      |
| 内存问题-OOM                                         |      |      |
| 内存问题-Stack Overflow                              |      |      |
| 网络问题                                             |      |      |
| 数据库死锁                                           |      |      |
| 慢sql                                                |      |      |
| 消息队列消息堆积                                     |      |      |
| 消息队列reblance                                     |      |      |



# 数据库死锁案例分析



### **InnoDB 有哪几类行锁？**

MySQL InnoDB 支持三种行锁定方式：

- **记录锁（Record Lock）** **：也被称为记录锁，属于单个行记录上的锁。**
- **间隙锁（Gap Lock）** **：锁定一个范围，不包括记录本身。**
- **临键锁（Next-key Lock）** **：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。**

InnoDB 的默认隔离级别 REPEATABLE-READ（可重读）是可以解决幻读问题发生的，主要有下面两种情况：

- **快照读** **：由 MVCC 机制来保证不出现幻读。**
- **当前读** **：使用 Next-Key Lock 进行加锁来保证不出现幻读。**



加锁规则：两个原则、两个优化、一个 bug

原则 1：加锁的基本单位是 next-key lock，前开后闭区间

原则 2：查找过程中访问到的对象才会加锁

优化 1：索引上的等值查询，给唯一索引加锁的时候，匹配上数据，next-key lock 退化为行锁

优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁

一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止



# OOM

#频繁FULLGC

#慢SQL

#接口延迟高